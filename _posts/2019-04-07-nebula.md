---
layout: post
title: "Exploit Education - Nebula: Write-up"
date: 2019-04-07 20:40:32.000000000 +8:00
excerpt: Write-ups for all the nebula challenges included in the VM created by exploit education. Nebula covers a variety of simple and intermediate challenges that cover Linux privilege escalation, common scripting language issues, and file system race conditions.
tags: [exploit education, solution, nebulla]
keywords: [exploit education, nebulla, solution, tip, answer, ctf]
---

## Introduction

As the challenges are relatively short, I will be slowly updating this post will the ones I have completed. The VM can be obtained at [Exploit Education](https://exploit.education/nebula/), a website created by Andrew Griffiths that teaches common (and less than common) weaknesses and vulnerabilities in Linux.

The main purpose of each level is to execute `getflag` using the 'flagxx' account instead of the normal 'levelxx' account.  

## Level00

This is a trivial question that requires some understanding of `find`. In this particular scenario, `man` pages did not help a lot, as it was flooded with options and configurations. After some reading, the following solution was obtained.

```
find . -executable -type f -user "flag00" 2>/dev/null
```

This results a list of files that are executable and are ran under the 'flagxx' account. Executing the files spawn a shell with sufficient privileges to execute `getflag`, thus solving the level.

## Level01

The source code for the level is provided for us. The code extracts the effective user ID and group ID of the process and overwrites the real and saved user and group IDs with them. From my understanding, real ID is the ID of the caller while effective ID is the ID the kernel uses to check for privileges. The target file, `/home/flag01/flag01`, has its suid bit set, so the effective ID will be the same as its real ID when it is executed. The file is owned by 'flag01', so its real ID will be 'flag01'. The above information can be verified by inspection of the results of the `ls -al` command. Following the changes of user and group IDs, the program calls `echo` with the parameters `and`, `now`, and `what?`. Interetingly, it looks for `echo` in the the environment variable `PATH`. Thus, a fake `echo` command can be created and its location can be inserted into the start of the `PATH` variable. This overrides the real `echo`. Since both the real and effective IDs have been changed to a more privileged account, the fake `echo` will be run using escalated privileges as well! We can use this to run the required `getflag` command.

The solution is as follows:

```
cd ~
touch badbash.c
vim badbash.c
```

Enter the following lines of C code and save the file:

```
#include <stdlib.h>

int main(){
    system("getflag");
}
```

Continue in the bash terminal with the following commands:

```
gcc badbash.c -o echo
PATH=~:$PATH
cd /home/flag01
./flag01
```

## Level02

This level is similar to the previous level. The given program executes the command `/bin/echo %s is cool` in bash, where `%s` is a custom defined string. This string can be defined by overwriting the `USER` variable. Furthermore, `;` is used to join two commands and the input string can be manipulated into the form ";getflag;". The terminal will first execute `/bin/echo`, which does nothing when it has no arguments, and then execute `getflag`. bash may not successfully parse `is cool`, but that is not our concern, as `getflag` has already been executed. As the real ID of this program is `flag02` and the suid bit of the file is set, `getflag` will be executed with the required privileges, and thus successfully unlock the flag.

The solution can be summarised as follows:

```
cd /home/flag02
USER=';getflag;'
./flag02
```


