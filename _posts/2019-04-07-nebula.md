---
layout: post
title: "Exploit Education - Nebula: Write-up"
date: 2019-04-07 20:40:32.000000000 +8:00
excerpt: Write-ups for all the nebula challenges included in the VM created by exploit education. Nebula covers a variety of simple and intermediate challenges that cover Linux privilege escalation, common scripting language issues, and file system race conditions.
tags: [exploit education, solution, nebulla]
keywords: [exploit education, nebulla, solution, tip, answer, ctf]
---

## Introduction

As the challenges are relatively short, I will be slowly updating this post will the ones I have completed. The VM can be obtained at [Exploit Education](https://exploit.education/nebula/), a website created by Andrew Griffiths that teaches common (and less than common) weaknesses and vulnerabilities in Linux.

The main purpose of each level is to bypass certain restrictions imposed by the system, let it running a command with the required privileges or extracting contents of a file. 

## Level00

This is a trivial question that requires some understanding of `find`. In this particular scenario, `man` pages did not help a lot, as it was flooded with options and configurations. After some reading, the following solution was obtained.

```
find . -executable -type f -user "flag00" 2>/dev/null
```

This results a list of files that are executable and are ran under the 'flagxx' account. Executing the files spawn a shell with sufficient privileges to execute `getflag`, thus solving the level.

## Level01

The source code for the level is provided for us. The code extracts the effective user ID and group ID of the process and overwrites the real and saved user and group IDs with them. From my understanding, real ID is the ID of the caller while effective ID is the ID the kernel uses to check for privileges. The target file, `/home/flag01/flag01`, has its suid bit set, so the effective ID will be the same as its real ID when it is executed. The file is owned by 'flag01', so its real ID will be 'flag01'. The above information can be verified by inspection of the results of the `ls -al` command. Following the changes of user and group IDs, the program calls `echo` with the parameters `and`, `now`, and `what?`. Interetingly, it looks for `echo` in the the environment variable `PATH`. Thus, a fake `echo` command can be created and its location can be inserted into the start of the `PATH` variable. This overrides the real `echo`. Since both the real and effective IDs have been changed to a more privileged account, the fake `echo` will be run using escalated privileges as well! We can use this to run the required `getflag` command.

The solution is as follows:

```
cd ~
touch badbash.c
vim badbash.c
```

Enter the following lines of C code and save the file:

```
#include <stdlib.h>

int main(){
    system("getflag");
}
```

Continue in the bash terminal with the following commands:

```
gcc badbash.c -o echo
PATH=~:$PATH
cd /home/flag01
./flag01
```

## Level02

This level is similar to the previous level. The given program executes the command `/bin/echo %s is cool` in bash, where `%s` is a custom defined string. This string can be defined by overwriting the `USER` variable. Furthermore, `;` is used to join two commands and the input string can be manipulated into the form ";getflag;". The terminal will first execute `/bin/echo`, which does nothing when it has no arguments, and then execute `getflag`. bash may not successfully parse `is cool`, but that is not our concern, as `getflag` has already been executed. As the real ID of this program is `flag02` and the suid bit of the file is set, `getflag` will be executed with the required privileges, and thus successfully unlock the flag.

The solution can be summarised as follows:

```
cd /home/flag02
USER=';getflag;'
./flag02
```

## Level03

A `crontab` is ran every few minutes presumably on the `writable.sh` file. Inspecting the contents reveal the following code:

```
#!/bin/sh

for i in /home/flag03/writable.d/* ; do
    (ulimit -t 5; bash -x "$i")
    rm -rf "$i"
done

```

It appears the this script fetches all the files in the "writable.d" directory and performs some commands on it and removes it after it is scanned. `ulimit -t` simply limits the time allows for the given program to run, and `bash -x`, according to the man page, shows all actions done in that script. Both commands do not limit how we access or execute the script, so I simply ignored them. The next reasonable action is to insert our own custom script into the "writable.d" directory. This is possible as we have the sufficient privileges, as evident from the results of `ls -al`. With this information in mind, we can derive our solution. A script that executes `getflag` will be stored in "writable.d". Executing `writable.sh` itself is futile, as it does not have suid bit set, thus we will be running with insufficient privileges. `crontab` runs with `root` in default configurations, thus this should be what we need to exploit.  As `crontab` redirects the output, we will store the output into a file at a specific location. This can be summarised as the following code.

```
cd /home/flag03/writable.d
echo "getflag > /tmp/res.txt" > scrpt.sh
chmod +x scrpt.sh
```

After waiting a while, check the contents of the "/tmp/res.txt" file by `cat /tmp/res.txt`. As expected, it shows we have successfully executed `getflag` on a required account.


## Level04

