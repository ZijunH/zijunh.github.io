---
layout: post
title: "Exploit Education - Nebula: Write-up"
date: 2019-04-07 20:40:32.000000000 +8:00
excerpt: Write-ups for all the nebula challenges included in the VM created by exploit education. Nebula covers a variety of simple and intermediate challenges that cover Linux privilege escalation, common scripting language issues, and file system race conditions.
tags: [exploit education, solution, nebulla]
keywords: [exploit education, nebulla, solution, tip, answer, ctf]
---

## Introduction

As the challenges are relatively short, I will be slowly updating this post will the ones I have completed. The VM can be obtained at [Exploit Education](https://exploit.education/nebula/), a website created by Andrew Griffiths that teaches common (and less than common) weaknesses and vulnerabilities in Linux.

The main purpose of each level is to execute `getflag` using the 'flagxx' account instead of the normal 'levelxx' account.  

## Level00

This is a trivial question that requires some understanding of `find`. In this particular scenario, `man` pages did not help a lot, as it was flooded with options and configurations. After some reading, the following solution was obtained.

```
find . -executable -type f -user "flag00" 2>/dev/null
```

This results a list of files that are executable and are ran under the 'flagxx' account. Executing the files spawn a shell with sufficient privileges to execute `getflag`, thus solving the level.

## Level01

The source code for the level is provided for us. The code extracts the effective user ID and group ID of the process and overwrites the real and saved user and group IDs with them. From my understanding, real ID is the ID of the caller while effective ID is the ID the kernel uses to check for privileges. As the target file, `/home/flag01/flag01`, is owner by 'flag01', its effective ID is 'flag01'; the real ID of the file is initially 'level01'. Following the changes of user and group IDs, the program calls `echo` with the parameters `and`, `now`, and `what?`. Interetingly, it looks for `echo` in the the environment variable `PATH`. Thus, a fake `echo` command can be created and its location can be inserted into the start of the `PATH` variable. This overrides the real `echo`. Since both the real and effective IDs have been changed to a more privileged account, the fake `echo` will be run using escalated privileges as well! We can use this to run the required `getflag` command.

The solution is as follows:

```
cd ~
touch badbash.c
vim badbash.c
```

Enter the following lines of C code and save the file:

```
#include <stdlib.h>

int main(){
    system("getflag");
}
```

Continue in the bash terminal with the following commands:

```
gcc badbash.c -o echo
PATH=~:$PATH
cd /home/flag01
./flag01
```


