---
layout: post
title: "Exploit Education - Nebula: Write-up"
date: 2019-04-07 20:40:32.000000000 +8:00
excerpt: Write-ups for all the nebula challenges included in the VM created by exploit education. Nebula covers a variety of simple and intermediate challenges that cover Linux privilege escalation, common scripting language issues, and file system race conditions.
tags: [exploit education, solution, nebulla]
keywords: [exploit education, nebulla, solution, tip, answer, ctf]
---

## Introduction

As the challenges are relatively short, I will be slowly updating this post will the ones I have completed. The VM can be obtained at [Exploit Education](https://exploit.education/nebula/), a website created by Andrew Griffiths that teaches common (and less than common) weaknesses and vulnerabilities in Linux.

The main purpose of each level is to bypass certain restrictions imposed by the system, and run `getflag` with the required privileges.


## Level00

This is a trivial question that requires some understanding of `find`. In this particular scenario, `man` pages did not help a lot, as it was flooded with options and configurations. After some reading, the following solution was obtained.

```
find . -executable -type f -user "flag00" 2>/dev/null
```

This results a list of files that are executable and are ran under the 'flagxx' account. Executing the files spawn a shell with sufficient privileges to execute `getflag`, thus solving the level.

## Level01

The source code for the level is provided for us. The code extracts the effective user ID and group ID of the process and overwrites the real and saved user and group IDs with them. From my understanding, real ID is the ID of the caller while effective ID is the ID the kernel uses to check for privileges. The target file, `/home/flag01/flag01`, has its suid bit set, so the effective ID will be the same as its real ID when it is executed. The file is owned by 'flag01', so its real ID will be 'flag01'. The above information can be verified by inspection of the results of the `ls -al` command. Following the changes of user and group IDs, the program calls `echo` with the parameters `and`, `now`, and `what?`. Interetingly, it looks for `echo` in the the environment variable `PATH`. Thus, a fake `echo` command can be created and its location can be inserted into the start of the `PATH` variable. This overrides the real `echo`. Since both the real and effective IDs have been changed to a more privileged account, the fake `echo` will be run using escalated privileges as well! We can use this to run the required `getflag` command.

The solution is as follows:

```
cd ~
touch badbash.c
vim badbash.c
```

Enter the following lines of C code and save the file:

```
#include <stdlib.h>

int main(){
    system("getflag");
}
```

Continue in the bash terminal with the following commands:

```
gcc badbash.c -o echo
PATH=~:$PATH
cd /home/flag01
./flag01
```

## Level02

This level is similar to the previous level. The given program executes the command `/bin/echo %s is cool` in bash, where `%s` is a custom defined string. This string can be defined by overwriting the `USER` variable. Furthermore, `;` is used to join two commands and the input string can be manipulated into the form ";getflag;". The terminal will first execute `/bin/echo`, which does nothing when it has no arguments, and then execute `getflag`. bash may not successfully parse `is cool`, but that is not our concern, as `getflag` has already been executed. As the real ID of this program is `flag02` and the suid bit of the file is set, `getflag` will be executed with the required privileges, and thus successfully unlock the flag.

The solution can be summarised as follows:

```
cd /home/flag02
USER=';getflag;'
./flag02
```

## Level03

A `crontab` is ran every few minutes presumably on the `writable.sh` file. Inspecting the contents reveal the following code:

```
#!/bin/sh

for i in /home/flag03/writable.d/* ; do
    (ulimit -t 5; bash -x "$i")
    rm -rf "$i"
done

```

It appears the this script fetches all the files in the "writable.d" directory and performs some commands on it and removes it after it is scanned. `ulimit -t` simply limits the time allows for the given program to run, and `bash -x`, according to the man page, shows all actions done in that script. Both commands do not limit how we access or execute the script, so I simply ignored them. The next reasonable action is to insert our own custom script into the "writable.d" directory. This is possible as we have the sufficient privileges, as evident from the results of `ls -al`. With this information in mind, we can derive our solution. A script that executes `getflag` will be stored in "writable.d". Executing `writable.sh` itself is futile, as it does not have suid bit set, thus we will be running with insufficient privileges. `crontab` runs with `root` in default configurations, thus this should be what we need to exploit.  As `crontab` redirects the output, we will store the output into a file at a specific location. This can be summarised as the following code.

```
cd /home/flag03/writable.d
echo "getflag > /tmp/res.txt" > scrpt.sh
chmod +x scrpt.sh
```

After waiting a while, check the contents of the "/tmp/res.txt" file by `cat /tmp/res.txt`. As expected, it shows we have successfully executed `getflag` on a required account.

## Level04

The key line of code that prevents the user from reading the token file directly is `strstr(argv[1], "token") != NULL`. From the `man` page, `strstr` returns the first occurence of "token" in "argv[1]". If the string token does not exist, then "NULL" is returned, and the file can be accessed as usual. If it does, the program throws an error and exits prematurely. To circumvent this, we can create a symbolic link, which is basically pointer to another file. As we can name this what ever we want, the check can be bypassed. The link is created using `ln`; as a symbolic link is required, `-s` is added as an argument. The solution for this problem is as follows:

```
ln -s /home/flag04/token symlink
/home/flag04/flag04 symlink
```

This prints out a long string, which is the password of the flag04 account. Switch into flag04 using `su - flag04`, enter the password, and you will have sufficient privileges to run `getflag`.


## Level05

Digging around the flag05 home folder using `ls -al` reveals 2 hidden folders: ".backup" and ".ssh". ".ssh" hints the way we need to log into "flag05" -- via ssh. Unfortunately, out account does not have sufficient privileges to read its contents, thus the entry point must be ".backup". ".backup" does not appear to be a standard folder name, and inspecting the contents inside reveal a .tgz file that is named "backup". Inspecting the type of the file using `file` reveals it has gzip compressed data, and fortunately our account can read it. `cd` back our home folder and extracting the file there using `tar zxvf` (z: gzip, x: decompress, v: show name, f: archive file name) produces a ".ssh" folder with ssh authorisation keys. Using that information, we can simple type `ssh flag05@localhost` to access flag05's account. The entire process can be summarised as the following commands:

```
cd ~
tar zxvf /home/flag05/.backup/backup-19072011.tgz
ssh flag05@localhost
getflag
```
